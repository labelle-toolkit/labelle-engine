//! iOS Build Configuration - Auto-generated by labelle CLI
//!
//! Usage:
//!   zig build ios       # Build for iOS device
//!   zig build ios-sim   # Build for iOS simulator
//!
//! Note: The sokol Zig module is accessed through engine.sokol to avoid
//! module conflicts. The sokol dependency is only used for linking sokol_clib.
//! The ios_main.zig template uses `const sokol = engine.sokol;`

const std = @import("std");

fn writeFile(b: *std.Build, step: *std.Build.Step, path: []const u8, contents: []const u8) void {
    const wf = b.addWriteFiles();
    _ = wf.add(path, contents);
    step.dependOn(&b.addInstallDirectory(.{
        .source_dir = wf.getDirectory(),
        .install_dir = .prefix,
        .install_subdir = ".",
    }).step);
}

/// Get iOS SDK path using xcrun
fn getIosSdkPath(b: *std.Build, sdk_name: []const u8) ?[]const u8 {
    const result = std.process.Child.run(.{
        .allocator = b.allocator,
        .argv = &.{ "xcrun", "--sdk", sdk_name, "--show-sdk-path" },
    }) catch return null;
    defer b.allocator.free(result.stdout);
    defer b.allocator.free(result.stderr);
    if (result.term == .Exited and result.term.Exited == 0) {
        const path = std.mem.trim(u8, result.stdout, &std.ascii.whitespace);
        if (path.len == 0) return null; // Reject empty paths
        return b.allocator.dupe(u8, path) catch null;
    }
    return null;
}

/// Configure SDK paths for a compile artifact (sokol_clib)
fn configureSdkPaths(b: *std.Build, artifact: *std.Build.Step.Compile, sdk_path: []const u8) void {
    artifact.root_module.addSystemIncludePath(.{ .cwd_relative = b.pathJoin(&.{ sdk_path, "usr/include" }) });
    artifact.root_module.addSystemFrameworkPath(.{ .cwd_relative = b.pathJoin(&.{ sdk_path, "System/Library/Frameworks" }) });
    artifact.root_module.addSystemFrameworkPath(.{ .cwd_relative = b.pathJoin(&.{ sdk_path, "System/Library/SubFrameworks" }) });
}

/// Add SDK library and framework paths to an executable
fn addExeSdkPaths(b: *std.Build, exe: *std.Build.Step.Compile, sdk_path: []const u8) void {
    exe.root_module.addLibraryPath(.{ .cwd_relative = b.pathJoin(&.{ sdk_path, "usr/lib" }) });
    exe.root_module.addFrameworkPath(.{ .cwd_relative = b.pathJoin(&.{ sdk_path, "System/Library/Frameworks" }) });
}

pub fn build(b: *std.Build) void {
    const optimize = b.standardOptimizeOption(.{});

    const app_name = "mobile_physics_test";

    // Detect iOS SDK paths using xcrun (required for C header includes and linking)
    // Note: We don't set b.sysroot to avoid path doubling issues during linking.
    // Device and simulator use different SDKs with architecture-specific libraries.
    const device_sdk = getIosSdkPath(b, "iphoneos") orelse
        @panic("Could not find iOS device SDK (iphoneos). Is Xcode installed?");
    const sim_sdk = getIosSdkPath(b, "iphonesimulator") orelse
        @panic("Could not find iOS simulator SDK (iphonesimulator). Is Xcode installed?");

    // iOS Device Target
    const ios_device_target = b.resolveTargetQuery(.{
        .cpu_arch = .aarch64,
        .os_tag = .ios,
    });

    // iOS Simulator Target (Apple Silicon Macs)
    // Use apple_a14 to enable NEON SIMD features required by box2d physics
    const ios_sim_target = b.resolveTargetQuery(.{
        .cpu_arch = .aarch64,
        .os_tag = .ios,
        .abi = .simulator,
        .cpu_model = .{ .explicit = &std.Target.aarch64.cpu.apple_a14 },
    });

    // iOS Device build
    // sokol dependency for linking C library (dont_link_system_libs=true for iOS)
    const ios_sokol = b.dependency("sokol", .{
        .target = ios_device_target,
        .optimize = optimize,
        .dont_link_system_libs = true,
    });

    // Configure sokol for iOS device - add SDK include paths for C header compilation
    configureSdkPaths(b, ios_sokol.artifact("sokol_clib"), device_sdk);

    // Engine provides sokol through engine.sokol (re-exported to avoid module conflicts)
    // iOS requires sokol backend (raylib not available)
    const ios_engine = b.dependency("labelle-engine", .{
        .target = ios_device_target,
        .optimize = optimize,
        .backend = .sokol,
        .physics = true,
    });

    // Create main module from project's main.zig (contains registries and scenes)
    const ios_main_mod = b.createModule(.{
        .root_source_file = b.path("../main.zig"),
        .target = ios_device_target,
        .optimize = optimize,
        .imports = &.{
            .{ .name = "labelle-engine", .module = ios_engine.module("labelle-engine") },
            .{ .name = "labelle-physics", .module = ios_engine.module("labelle-physics") },
        },
    });

    const ios_exe = b.addExecutable(.{
        .name = app_name,
        .root_module = b.createModule(.{
            .root_source_file = b.path("../ios_main.zig"),
            .target = ios_device_target,
            .optimize = optimize,
            .imports = &.{
                .{ .name = "labelle-engine", .module = ios_engine.module("labelle-engine") },
                .{ .name = "main", .module = ios_main_mod },
            },
        }),
    });

    // Link sokol C library (for iOS Metal backend)
    ios_exe.linkLibrary(ios_sokol.artifact("sokol_clib"));
    ios_exe.linkLibC();

    // Add iOS device SDK library and framework search paths
    addExeSdkPaths(b, ios_exe, device_sdk);

    // Link iOS frameworks
    ios_exe.root_module.linkFramework("Foundation", .{});
    ios_exe.root_module.linkFramework("UIKit", .{});
    ios_exe.root_module.linkFramework("Metal", .{});
    ios_exe.root_module.linkFramework("MetalKit", .{});
    ios_exe.root_module.linkFramework("AudioToolbox", .{});
    ios_exe.root_module.linkFramework("AVFoundation", .{});

    const ios_step = b.step("ios", "Build for iOS device");
    ios_step.dependOn(&ios_exe.step);
    ios_step.dependOn(&b.addInstallArtifact(ios_exe, .{}).step);

    // iOS Simulator build
    const sim_sokol = b.dependency("sokol", .{
        .target = ios_sim_target,
        .optimize = optimize,
        .dont_link_system_libs = true,
    });

    // Configure sokol for iOS Simulator - add SDK include paths for C header compilation
    configureSdkPaths(b, sim_sokol.artifact("sokol_clib"), sim_sdk);

    // iOS requires sokol backend (raylib not available)
    const sim_engine = b.dependency("labelle-engine", .{
        .target = ios_sim_target,
        .optimize = optimize,
        .backend = .sokol,
        .physics = true,
    });

    // Create main module from project's main.zig (contains registries and scenes)
    const sim_main_mod = b.createModule(.{
        .root_source_file = b.path("../main.zig"),
        .target = ios_sim_target,
        .optimize = optimize,
        .imports = &.{
            .{ .name = "labelle-engine", .module = sim_engine.module("labelle-engine") },
            .{ .name = "labelle-physics", .module = sim_engine.module("labelle-physics") },
        },
    });

    const sim_exe = b.addExecutable(.{
        .name = app_name ++ "_sim",
        .root_module = b.createModule(.{
            .root_source_file = b.path("../ios_main.zig"),
            .target = ios_sim_target,
            .optimize = optimize,
            .imports = &.{
                .{ .name = "labelle-engine", .module = sim_engine.module("labelle-engine") },
                .{ .name = "main", .module = sim_main_mod },
            },
        }),
    });

    // Link sokol C library (for iOS Simulator Metal backend)
    sim_exe.linkLibrary(sim_sokol.artifact("sokol_clib"));
    sim_exe.linkLibC();

    // Add iOS simulator SDK library and framework search paths
    addExeSdkPaths(b, sim_exe, sim_sdk);

    sim_exe.root_module.linkFramework("Foundation", .{});
    sim_exe.root_module.linkFramework("UIKit", .{});
    sim_exe.root_module.linkFramework("Metal", .{});
    sim_exe.root_module.linkFramework("MetalKit", .{});
    sim_exe.root_module.linkFramework("AudioToolbox", .{});
    sim_exe.root_module.linkFramework("AVFoundation", .{});

    const sim_step = b.step("ios-sim", "Build for iOS simulator");
    sim_step.dependOn(&sim_exe.step);
    sim_step.dependOn(&b.addInstallArtifact(sim_exe, .{}).step);

    // Package a minimal .app bundle for Simulator installation.
    // This enables `xcrun simctl install/launch` in CI.
    // Layout: zig-out/app/<AppName>.app/{Info.plist,<executable>}
    // `addWriteFile` and `addInstallFile` are rooted at the install prefix, so
    // use paths relative to that prefix (no leading "zig-out/").
    const app_dir = b.pathJoin(&.{ "app", app_name ++ ".app" });
    const plist_path = b.pathJoin(&.{ app_dir, "Info.plist" });
    const executable_path = b.pathJoin(&.{ app_dir, app_name });

    const bundle_id = "games.labelle.mobile-physics-test";

    const plist = b.fmt(
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" ++
            "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n" ++
            "<plist version=\"1.0\">\n" ++
            "<dict>\n" ++
            "  <key>CFBundleDevelopmentRegion</key><string>en</string>\n" ++
            "  <key>CFBundleExecutable</key><string>{s}</string>\n" ++
            "  <key>CFBundleIdentifier</key><string>{s}</string>\n" ++
            "  <key>CFBundleInfoDictionaryVersion</key><string>6.0</string>\n" ++
            "  <key>CFBundleName</key><string>{s}</string>\n" ++
            "  <key>CFBundlePackageType</key><string>APPL</string>\n" ++
            "  <key>CFBundleShortVersionString</key><string>0.0.0</string>\n" ++
            "  <key>CFBundleVersion</key><string>0</string>\n" ++
            "  <key>LSRequiresIPhoneOS</key><true/>\n" ++
            "</dict>\n" ++
            "</plist>\n",
        .{ app_name, bundle_id, app_name },
    );

    const app_step = b.step("ios-sim-app", "Build iOS simulator .app");
    app_step.dependOn(sim_step);

    // Create Info.plist
    writeFile(b, app_step, plist_path, plist);

    // Copy binary into .app bundle
    const copy_exe = b.addInstallFile(sim_exe.getEmittedBin(), executable_path);
    app_step.dependOn(&copy_exe.step);
}
