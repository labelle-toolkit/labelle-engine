.header
// ============================================================================
// AUTO-GENERATED FILE - DO NOT EDIT
// ============================================================================
// This file is generated by labelle-engine from project.labelle
// Project: {s}
//
// Any manual changes will be overwritten on next generation.
//
// To regenerate: zig build generate
// To modify settings: edit project.labelle instead
//
// This project uses the sokol backend with callback-based architecture for iOS.
// The main loop is driven by sokol_app callbacks (init, frame, cleanup, event).
// Project configuration is embedded at compile time for iOS compatibility.
// ============================================================================

const std = @import("std");
const engine = @import("labelle-engine");
const ProjectConfig = engine.ProjectConfig;

// Sokol bindings - re-exported from engine for iOS callback architecture
const sokol = engine.sokol;
const sg = sokol.gfx;
const sgl = sokol.gl;
const sapp = sokol.app;

.include ../partials/imports.txt
.include ../partials/registries.txt
.include ../partials/hooks.txt
.include ../partials/task_engine.txt
.include ../partials/loader.txt

.include ../partials/sokol_state.txt

.init_cb
// Sokol app callbacks for iOS
export fn init() void {{
    state.ci_test = std.posix.getenv("CI_TEST") != null;

    // Initialize sokol_gfx with sokol_app's rendering context
    sg.setup(.{{
        .environment = sokol.glue.environment(),
        .logger = .{{ .func = sokol.log.func }},
    }});

    // Initialize sokol_gl for 2D drawing (must be after sg.setup)
    sgl.setup(.{{
        .logger = .{{ .func = sokol.log.func }},
    }});

    // Use page allocator for simplicity in callback context
    state.allocator = std.heap.page_allocator;

    // Initialize game with embedded config (iOS doesn't load from filesystem)
    game_storage = Game.init(state.allocator, .{{
        .window = .{{
            .width = {d},
            .height = {d},
            .title = "{s}",
            .target_fps = {d},
        }},
        .clear_color = .{{ .r = 30, .g = 35, .b = 45 }},
    }}) catch |err| {{
        std.debug.print("Failed to initialize game: {{}}\n", .{{err}});
        sapp.quit();
        return;
    }};
    state.game = &game_storage;
    state.game.?.fixPointers();

.camera_config
    // Apply embedded camera configuration
    state.game.?.setCameraPosition({d:.1}, {d:.1});
    state.game.?.setCameraZoom({d:.2});
.camera_config_end

.init_cb_end
    const ctx = engine.SceneContext.init(state.game.?);

    // Emit scene_before_load hook for initial scene
    state.game.?.hook_dispatcher.emit(.{{ .scene_before_load = .{{ .name = initial_scene.name, .allocator = state.allocator }} }});

    // Load initial scene
    scene_storage = Loader.load(initial_scene, ctx) catch |err| {{
        std.debug.print("Failed to load scene: {{}}\n", .{{err}});
        sapp.quit();
        return;
    }};
    state.scene = &scene_storage;

    // Emit scene_load hook for initial scene
    state.game.?.hook_dispatcher.emit(.{{ .scene_load = .{{ .name = initial_scene.name }} }});

    state.initialized = true;
    std.debug.print("Sokol iOS backend initialized successfully!\n", .{{}});
    std.debug.print("Window size: {{}}x{{}}\n", .{{ sapp.width(), sapp.height() }});

    // For CI testing, we'll exit after a few frames (handled in frame callback)
}}

.frame_cb
export fn frame() void {{
    if (!state.initialized or state.game == null or state.scene == null) return;

    // CI test mode: exit after 10 frames
    state.frame_count += 1;
    if (state.ci_test) {{
        if (state.frame_count > 10) {{
            state.should_quit = true;
            sapp.quit();
            return;
        }}
    }}

    // Get delta time from sokol
    const dt: f32 = @floatCast(sapp.frameDuration());

    // Update scene (runs scripts, etc.)
    state.scene.?.update(dt);

    // Sync ECS components to graphics
    state.game.?.getPipeline().sync(state.game.?.getRegistry());

    // Begin sokol render pass (required for sokol backend)
    var pass_action: sg.PassAction = .{{}};
    pass_action.colors[0] = .{{
        .load_action = .CLEAR,
        .clear_value = .{{ .r = 0.118, .g = 0.137, .b = 0.176, .a = 1.0 }},
    }};
    sg.beginPass(.{{
        .action = pass_action,
        .swapchain = sokol.glue.swapchain(),
    }});

    // Render using the retained engine
    const re = state.game.?.getRetainedEngine();
    re.beginFrame();
    re.render();
    re.endFrame();

    // End sokol render pass and commit
    sg.endPass();
    sg.commit();
}}

.cleanup_cb
export fn cleanup() void {{
    // Emit scene_unload hook if we still have the initial scene
    if (state.initialized and state.game != null) {{
        if (state.game.?.getCurrentSceneName() == null) {{
            state.game.?.hook_dispatcher.emit(.{{ .scene_unload = .{{ .name = initial_scene.name }} }});
        }}
    }}

    // Cleanup scene
    if (state.scene) |scene| {{
        scene.deinit();
        state.scene = null;
    }}

    // Cleanup game
    if (state.game) |game| {{
        game.deinit();
        state.game = null;
    }}

    // Cleanup sokol in reverse order of initialization
    sgl.shutdown();
    sg.shutdown();

    std.debug.print("Sokol iOS backend cleanup complete.\n", .{{}});
}}

.event_cb
export fn event(ev: ?*const sapp.Event) void {{
    const e = ev orelse return;

    // iOS touch events can be handled here
    switch (e.type) {{
        .TOUCHES_BEGAN, .TOUCHES_MOVED, .TOUCHES_ENDED, .TOUCHES_CANCELLED => {{
            // Touch handling for iOS
            // TODO: Forward to game input system
        }},
        .KEY_DOWN => {{
            // Keyboard (if available)
            if (e.key_code == .ESCAPE) {{
                sapp.quit();
            }}
        }},
        else => {{}},
    }}
}}

.main_fn
pub fn main() void {{
    // Run sokol app with iOS-optimized settings
    sapp.run(.{{
        .init_cb = init,
        .frame_cb = frame,
        .cleanup_cb = cleanup,
        .event_cb = event,
        .width = {d},
        .height = {d},
        .window_title = "{s}",
        .high_dpi = true,  // Enable Retina display support
        .icon = .{{ .sokol_default = true }},
        .logger = .{{ .func = sokol.log.func }},
    }});
}}
