.header
// ============================================================================
// AUTO-GENERATED FILE - DO NOT EDIT
// ============================================================================
// This file is generated by labelle-engine from project.labelle
// Project: {s}
//
// Any manual changes will be overwritten on next generation.
//
// To regenerate: zig build generate
// To modify settings: edit project.labelle instead
// ============================================================================

const std = @import("std");
const engine = @import("labelle-engine");

const Game = engine.Game;
const ProjectConfig = engine.ProjectConfig;

.prefab_import
const {s}_prefab = @import("prefabs/{s}.zig");
.component_import
const {s}_comp = @import("components/{s}.zig");
.component_export
pub const {s} = {s}_comp.{s};
.script_import
const {s}_script = @import("scripts/{s}.zig");
.prefab_registry_empty
// Registries
pub const Prefabs = engine.PrefabRegistry(.{{}});
.prefab_registry_start
// Registries
pub const Prefabs = engine.PrefabRegistry(.{{
.prefab_registry_item
    {s}_prefab,
.prefab_registry_end
}});
.main_module
const main_module = @This();
.component_registry_empty
pub const Components = engine.ComponentRegistry(struct {{}});
.component_registry_start
pub const Components = engine.ComponentRegistry(struct {{
.component_registry_item
    pub const {s} = main_module.{s};
.component_registry_end
}});
.script_registry_empty
pub const Scripts = engine.ScriptRegistry(struct {{}});
.script_registry_start
pub const Scripts = engine.ScriptRegistry(struct {{
.script_registry_item
    pub const {s} = {s}_script;
.script_registry_end
}});
.loader
pub const Loader = engine.SceneLoader(Prefabs, Components, Scripts);
pub const initial_scene = @import("scenes/{s}.zon");

.main_fn
pub fn main() !void {{
    const ci_test = std.posix.getenv("CI_TEST") != null;

    var gpa = std.heap.GeneralPurposeAllocator(.{{}}){{}};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const project = try ProjectConfig.load(allocator, "project.labelle");
    defer project.deinit(allocator);

    // Convert title to sentinel-terminated string for window creation
    const title = try allocator.dupeZ(u8, project.window.title);
    defer allocator.free(title);

    var game = try Game.init(allocator, .{{
        .window = .{{
            .width = project.window.width,
            .height = project.window.height,
            .title = title,
            .target_fps = project.window.target_fps,
            .hidden = ci_test,
        }},
        .clear_color = .{{ .r = 30, .g = 35, .b = 45 }},
    }});
    game.fixPointers(); // Fix internal pointers after struct is in final location
    defer game.deinit();

    // Load atlases from project config
    for (project.resources.atlases) |atlas| {{
        try game.loadAtlas(atlas.name, atlas.json, atlas.texture);
    }}

    // Apply camera configuration from project
    if (project.camera.x != null or project.camera.y != null) {{
        game.setCameraPosition(project.camera.x orelse 0, project.camera.y orelse 0);
    }}
    if (project.camera.zoom != 1.0) {{
        game.setCameraZoom(project.camera.zoom);
    }}

    const ctx = engine.SceneContext.init(&game);
    var scene = try Loader.load(initial_scene, ctx);
    defer scene.deinit();

    if (ci_test) return;

    while (game.isRunning()) {{
        const dt = game.getDeltaTime();
        scene.update(dt);
        game.getPipeline().sync(game.getRegistry());

        const re = game.getRetainedEngine();
        re.beginFrame();
        re.render();
        re.endFrame();
    }}
}}
