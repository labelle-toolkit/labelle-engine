//! Example 1: labelle-engine Scene + Visual Rendering
//!
//! This example demonstrates the labelle-engine workflow:
//! - Project configuration via .labelle file (ZON format)
//! - Scene loading from .zon files
//! - Prefabs, components, and scripts
//! - Visual rendering with sprite atlases
//!
//! Project structure:
//!   project.labelle     - Project config (name, initial_scene, window settings)
//!   scenes/             - Scene definitions (.zon files)
//!   prefabs/            - Entity templates
//!   components/         - ECS component definitions
//!   scripts/            - Per-frame game logic
//!   fixtures/           - Assets (sprites, atlases)

const std = @import("std");
const engine = @import("labelle-engine");

const Game = engine.Game;
const ProjectConfig = engine.ProjectConfig;

// =============================================================================
// Comptime imports (will be auto-generated by labelle-gui in the future)
// =============================================================================

// Sprite data
const character_frames = @import("fixtures/characters_frames.zon");

// Prefabs
const PlayerPrefab = @import("prefabs/player.zig");
const EnemyPrefab = @import("prefabs/enemy.zig");

// Components
const velocity = @import("components/velocity.zig");
const health = @import("components/health.zig");
const gravity_comp = @import("components/gravity.zig");

pub const Velocity = velocity.Velocity;
pub const Health = health.Health;
pub const Gravity = gravity_comp.Gravity;

// Scripts
const gravity = @import("scripts/gravity.zig");

// =============================================================================
// Registries
// =============================================================================

pub const Prefabs = engine.PrefabRegistry(.{
    PlayerPrefab,
    EnemyPrefab,
});

const main_module = @This();

pub const Components = engine.ComponentRegistry(struct {
    pub const Velocity = main_module.Velocity;
    pub const Health = main_module.Health;
    pub const Gravity = main_module.Gravity;
});

pub const Scripts = engine.ScriptRegistry(struct {
    pub const gravity = main_module.gravity;
});

// Scene loader
pub const Loader = engine.SceneLoader(Prefabs, Components, Scripts);

// Scene (loaded at comptime from scenes/ folder)
pub const game_scene = @import("scenes/game_scene.zon");

// =============================================================================
// Main
// =============================================================================

pub fn main() !void {
    const ci_test = std.posix.getenv("CI_TEST") != null;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Load project configuration from .labelle file
    const project = ProjectConfig.load(allocator, "project.labelle") catch |err| {
        std.debug.print("Error loading project.labelle: {}\n", .{err});
        return err;
    };
    defer project.deinit(allocator);

    std.debug.print(
        \\labelle-engine Example 1
        \\========================
        \\
        \\Project: {s}
        \\Description: {s}
        \\Initial scene: {s}
        \\Window: {d}x{d}
        \\
    , .{
        project.name,
        project.description,
        project.initial_scene,
        project.window.width,
        project.window.height,
    });

    // Initialize Game with config from .labelle
    var game = try Game.init(allocator, .{
        .window = .{
            .width = project.window.width,
            .height = project.window.height,
            .title = "labelle-engine Example",
            .target_fps = project.window.target_fps,
            .hidden = ci_test,
        },
        .clear_color = .{ .r = 30, .g = 35, .b = 45 },
    });
    defer game.deinit();

    // Load atlas
    const re = game.getRetainedEngine();
    try re.loadAtlasComptime("characters", character_frames, "fixtures/characters.png");

    // Load the initial scene
    const ctx = engine.SceneContext.init(&game);
    var scene = try Loader.load(game_scene, ctx);
    defer scene.deinit();

    std.debug.print("Scene loaded: {s}\n", .{scene.name});
    std.debug.print("Entities: {d}\n\n", .{scene.entityCount()});

    // Verify initial_scene matches loaded scene
    std.debug.assert(std.mem.eql(u8, project.initial_scene, scene.name));
    std.debug.print("Assertions passed\n\n", .{});

    if (ci_test) {
        std.debug.print("CI mode: exiting\n", .{});
        return;
    }

    // Game loop
    while (game.isRunning()) {
        const dt = game.getDeltaTime();

        // Update scene (runs scripts)
        scene.update(dt);

        // Sync ECS to renderer
        game.getPipeline().sync(game.getRegistry());

        // Render
        re.beginFrame();
        re.render();
        re.endFrame();
    }

    std.debug.print("Example 1 completed\n", .{});
}
