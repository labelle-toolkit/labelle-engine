.header
// ============================================================================
// AUTO-GENERATED FILE - DO NOT EDIT
// ============================================================================
// This file is generated by labelle-engine from project.labelle
// Project: {s}
//
// Any manual changes will be overwritten on next generation.
//
// To regenerate: zig build generate
// To modify settings: edit project.labelle instead
//
// This project uses the bgfx backend with GLFW window management.
// bgfx provides cross-platform GPU rendering (Metal, DirectX, Vulkan, OpenGL).
// ============================================================================

const std = @import("std");
const builtin = @import("builtin");
const engine = @import("labelle-engine");
const ProjectConfig = engine.ProjectConfig;

// GLFW and bgfx bindings
const zglfw = @import("zglfw");
const zbgfx = @import("zbgfx");
const bgfx = zbgfx.bgfx;
const gfx = @import("labelle-gfx");
const BgfxBackend = gfx.BgfxBackend;

.plugin_import
const {s} = @import("{s}");
.enum_import
const {s}_enum = @import("enums/{s}.zig");
.enum_export
pub const {s} = {s}_enum.{s};
.game_id_export
pub const GameId = {s};
.plugin_bind
pub const {s}Bind{s} = {s}.{s}({s}, engine.EngineTypes);
.plugin_bind_struct_start
const {s}BindComponents = struct {{
.plugin_bind_struct_item
    pub const {s} = {s}Bind{s}.{s};
.plugin_bind_struct_end
}};
.prefab_import
const {s}_prefab = @import("prefabs/{s}.zon");
.component_import
const {s}_comp = @import("components/{s}.zig");
.component_export
pub const {s} = {s}_comp.{s};
.script_import
const {s}_script = @import("scripts/{s}.zig");
.hook_import
const {s}_hooks = @import("hooks/{s}.zig");
.main_module
const main_module = @This();
.prefab_registry_empty
pub const Prefabs = engine.PrefabRegistry(.{{}});
.prefab_registry_start
pub const Prefabs = engine.PrefabRegistry(.{{
.prefab_registry_item
    .{s} = {s}_prefab,
.prefab_registry_end
}});
.component_registry_empty
pub const Components = engine.ComponentRegistry(struct {{
    // Engine built-in components
    pub const Position = engine.Position;
    pub const Sprite = engine.Sprite;
    pub const Shape = engine.Shape;
    pub const Text = engine.Text;
.physics_components
    // Physics components (auto-included when physics is enabled)
    pub const RigidBody = engine.PhysicsComponents.RigidBody;
    pub const Collider = engine.PhysicsComponents.Collider;
    pub const Velocity = engine.PhysicsComponents.Velocity;
.component_registry_empty_end
}});
.component_registry_start
pub const Components = engine.ComponentRegistry(struct {{
    // Engine built-in components
    pub const Position = engine.Position;
    pub const Sprite = engine.Sprite;
    pub const Shape = engine.Shape;
    pub const Text = engine.Text;
    // Project components
.component_registry_item
    pub const {s} = main_module.{s};
.component_registry_bind_item
    pub const {s} = {s}Bind{s}.{s};
.component_registry_physics
    // Physics components (auto-included when physics is enabled)
    pub const RigidBody = engine.PhysicsComponents.RigidBody;
    pub const Collider = engine.PhysicsComponents.Collider;
    pub const Velocity = engine.PhysicsComponents.Velocity;
.component_registry_end
}});
.component_registry_multi_empty_start
pub const Components = engine.ComponentRegistryMulti(.{{
    struct {{
        // Engine built-in components
        pub const Position = engine.Position;
        pub const Sprite = engine.Sprite;
        pub const Shape = engine.Shape;
        pub const Text = engine.Text;
.component_registry_multi_physics
        // Physics components (auto-included when physics is enabled)
        pub const RigidBody = engine.PhysicsComponents.RigidBody;
        pub const Collider = engine.PhysicsComponents.Collider;
        pub const Velocity = engine.PhysicsComponents.Velocity;
.component_registry_multi_empty_base_end
    }},
.component_registry_multi_start
pub const Components = engine.ComponentRegistryMulti(.{{
    struct {{
        // Engine built-in components
        pub const Position = engine.Position;
        pub const Sprite = engine.Sprite;
        pub const Shape = engine.Shape;
        pub const Text = engine.Text;
        // Project components
.component_registry_multi_item
        pub const {s} = main_module.{s};
.bind_component_item
        pub const {s} = {s}Bind{s}.{s};
.component_registry_multi_physics_start
        // Physics components (auto-included when physics is enabled)
        pub const RigidBody = engine.PhysicsComponents.RigidBody;
        pub const Collider = engine.PhysicsComponents.Collider;
        pub const Velocity = engine.PhysicsComponents.Velocity;
.component_registry_multi_base_end
    }},
.component_registry_multi_plugin
    {s}.{s},
.component_registry_multi_bind
    {s}Bind{s},
.component_registry_multi_end
}});
.script_registry_empty
pub const Scripts = engine.ScriptRegistry(struct {{}});
.script_registry_start
pub const Scripts = engine.ScriptRegistry(struct {{
.script_registry_item
    pub const {s} = {s}_script;
.script_registry_end
}});
.plugin_engine_hooks
const {s}_engine_hooks = {s}.{s}(GameId, {s}, {s}_hooks.{s}, engine.EngineTypes);
pub const {s}Context = {s}_engine_hooks.Context;
.hooks_empty
const Game = engine.Game;
.hooks_start
const Hooks = engine.MergeEngineHooks(.{{
.hooks_item
    {s}_hooks,
.hooks_plugin_item
    {s}_engine_hooks,
.hooks_end
}});
const Game = engine.GameWith(Hooks);
.task_engine_empty

.task_engine_start
// Task engine with auto-wired hooks
const TaskHooks = {s}.hooks.MergeTasksHooks({s}, {s}, .{{
.task_engine_hook_item
    {s}_hooks,
.task_engine_end
}});
const TaskDispatcher = {s}.hooks.HookDispatcher({s}, {s}, TaskHooks);
pub const TaskEngine = {s}.EngineWithHooks({s}, {s}, TaskDispatcher);
.loader
pub const Loader = engine.SceneLoader(Prefabs, Components, Scripts);
pub const initial_scene = @import("scenes/{s}.zon");

.native_helpers
// Platform-specific native window handle helpers
fn getNativeWindowHandle(window: *zglfw.Window) ?*anyopaque {{
    if (builtin.os.tag == .macos) {{
        return zglfw.getCocoaWindow(window);
    }} else if (builtin.os.tag == .linux) {{
        const x11_window = zglfw.getX11Window(window);
        return @ptrFromInt(x11_window);
    }} else if (builtin.os.tag == .windows) {{
        if (zglfw.getWin32Window(window)) |hwnd| {{
            return @ptrCast(hwnd);
        }}
    }}
    return null;
}}

fn getNativeDisplayHandle() ?*anyopaque {{
    if (builtin.os.tag == .linux) {{
        return zglfw.getX11Display();
    }}
    return null;
}}

.main_fn
pub fn main() !void {{
    const allocator = std.heap.page_allocator;
    const ci_test = std.posix.getenv("CI_TEST") != null;

    // Load project configuration
    const project = try ProjectConfig.load(allocator, "project.labelle");
    defer project.deinit(allocator);

    const width: u32 = @intCast(project.window.width);
    const height: u32 = @intCast(project.window.height);

    // Initialize GLFW
    zglfw.init() catch |err| {{
        std.log.err("Failed to initialize GLFW: {{}}", .{{err}});
        return error.GlfwInitFailed;
    }};
    defer zglfw.terminate();

    // Configure window hints for bgfx (no OpenGL context)
    zglfw.windowHint(.client_api, .no_api);
    zglfw.windowHint(.decorated, true);
    zglfw.windowHint(.resizable, project.window.resizable);
    if (ci_test) {{
        zglfw.windowHint(.visible, false);
    }}

    // Create window
    const title = allocator.dupeZ(u8, project.window.title) catch {{
        std.log.err("Failed to allocate title", .{{}});
        return error.OutOfMemory;
    }};
    defer allocator.free(title);

    const window = zglfw.Window.create(
        @intCast(width),
        @intCast(height),
        title,
        null,
    ) catch |err| {{
        std.log.err("Failed to create window: {{}}", .{{err}});
        return error.WindowCreationFailed;
    }};
    defer window.destroy();

    // Get native window handle for bgfx
    const native_window_handle = getNativeWindowHandle(window);
    const native_display_handle = getNativeDisplayHandle();

    if (native_window_handle == null) {{
        std.log.err("Failed to get native window handle", .{{}});
        return error.NativeWindowHandleFailed;
    }}

    // Set screen size before init
    BgfxBackend.setScreenSize(@intCast(width), @intCast(height));

    // Initialize bgfx
    BgfxBackend.initBgfx(native_window_handle, native_display_handle) catch |err| {{
        std.log.err("Failed to initialize bgfx: {{}}", .{{err}});
        return error.BgfxInitFailed;
    }};
    defer BgfxBackend.closeWindow();

    std.log.info("bgfx initialized - Renderer: {{s}}", .{{bgfx.getRendererName(bgfx.getRendererType())}});

    // Initialize game
    var game = try Game.init(allocator, .{{
        .window = .{{
            .width = project.window.width,
            .height = project.window.height,
            .title = title,
            .target_fps = project.window.target_fps,
        }},
        .clear_color = .{{ .r = 30, .g = 35, .b = 45 }},
    }});
    defer game.deinit();
    game.fixPointers();

    // Load atlases from project config
    for (project.resources.atlases) |atlas| {{
        game.loadAtlas(atlas.name, atlas.json, atlas.texture) catch |err| {{
            std.log.warn("Failed to load atlas {{s}}: {{any}}", .{{ atlas.name, err }});
        }};
    }}

    // Apply camera configuration
    if (project.camera.x != null or project.camera.y != null) {{
        game.setCameraPosition(project.camera.x orelse 0, project.camera.y orelse 0);
    }}
    if (project.camera.zoom != 1.0) {{
        game.setCameraZoom(project.camera.zoom);
    }}

    const ctx = engine.SceneContext.init(&game);

    // Emit scene_before_load hook
    game.hook_dispatcher.emit(.{{ .scene_before_load = .{{ .name = initial_scene.name, .allocator = allocator }} }});

    // Load initial scene
    var scene = try Loader.load(initial_scene, ctx);
    defer scene.deinit();

    // Emit scene_load hook
    game.hook_dispatcher.emit(.{{ .scene_load = .{{ .name = initial_scene.name }} }});

    std.log.info("bgfx backend initialized successfully!", .{{}});

    // Main loop
    var frame_count: u32 = 0;
    var last_time = std.time.nanoTimestamp();

    while (!window.shouldClose()) {{
        // Handle events
        zglfw.pollEvents();

        // Check for escape key
        if (window.getKey(.escape) == .press) {{
            window.setShouldClose(true);
            break;
        }}

        // CI test mode: exit after some frames
        if (ci_test and frame_count >= 60) {{
            std.log.info("CI test: completed {{}} frames", .{{frame_count}});
            break;
        }}

        // Calculate delta time
        const current_time = std.time.nanoTimestamp();
        const dt: f32 = @as(f32, @floatFromInt(current_time - last_time)) / 1_000_000_000.0;
        last_time = current_time;

        // Update scene
        game.gizmos.clearGizmos();
        scene.update(dt);

        // Sync ECS to graphics
        game.getPipeline().sync(game.getRegistry());

        // Render
        BgfxBackend.beginDrawing();
        BgfxBackend.clearBackground(BgfxBackend.color(30, 35, 45, 255));

        const re = game.getRetainedEngine();
        re.beginFrame();
        re.render();
        game.gizmos.renderStandaloneGizmos();
        re.endFrame();

        BgfxBackend.endDrawing();

        frame_count += 1;
    }}

    // Emit scene_unload hook
    game.hook_dispatcher.emit(.{{ .scene_unload = .{{ .name = initial_scene.name }} }});

    std.log.info("bgfx backend shutdown complete.", .{{}});
}}
