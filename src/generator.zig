// Project file generator for labelle-engine
//
// Generates build.zig, build.zig.zon, and main.zig based on:
// - project.labelle configuration
// - Folder contents (prefabs/, components/, scripts/, scenes/)
//
// Usage:
//   const generator = @import("labelle-engine").generator;
//
//   // Generate all project files
//   try generator.generateProject(allocator, ".");
//
// Or via build step:
//   zig build generate

const std = @import("std");
const project_config = @import("project_config.zig");

const ProjectConfig = project_config.ProjectConfig;

/// Options for generating build.zig.zon
pub const BuildZonOptions = struct {
    /// Path to labelle-engine (for local development). If null, uses URL.
    engine_path: ?[]const u8 = null,
};

/// Generate build.zig.zon content
pub fn generateBuildZon(allocator: std.mem.Allocator, config: ProjectConfig, options: BuildZonOptions) ![]const u8 {
    var buf: std.ArrayListUnmanaged(u8) = .{};
    const writer = buf.writer(allocator);

    try writer.writeAll(
        \\// Generated by labelle-engine
        \\// NOTE: On first build, Zig may report "invalid fingerprint" - update with the suggested value
        \\.{
        \\
    );

    // Generate a deterministic fingerprint based on project name
    // Zig requires a fingerprint - it may need to be updated with Zig's suggested value on first build
    var hash = std.hash.Fnv1a_64.init();
    hash.update(config.name);
    hash.update("labelle-game-v1");
    const fingerprint = hash.final();
    try writer.print("    .fingerprint = 0x{x},\n", .{fingerprint});

    // Name (convert to identifier)
    try writer.print("    .name = .{s},\n", .{config.name});
    try writer.writeAll("    .version = \"0.1.0\",\n");

    // Dependencies
    try writer.writeAll("    .dependencies = .{\n");
    try writer.writeAll("        .@\"labelle-engine\" = .{\n");

    if (options.engine_path) |path| {
        // Local development mode - use path
        try writer.print("            .path = \"{s}\",\n", .{path});
    } else {
        // Production mode - use URL (user will need to add hash after first build)
        try writer.writeAll("            // For local development, replace .url with:\n");
        try writer.writeAll("            // .path = \"path/to/labelle-engine\",\n");
        try writer.writeAll("            .url = \"git+https://github.com/labelle-toolkit/labelle-engine\",\n");
        try writer.writeAll("            // .hash = \"...\",  // Add after first build\n");
    }

    try writer.writeAll("        },\n");

    // Add plugin dependencies
    for (config.plugins) |plugin| {
        try writer.print("        .@\"{s}\" = .{{\n", .{plugin.name});
        try writer.print("            .url = \"git+https://github.com/labelle-toolkit/{s}\",\n", .{plugin.name});
        try writer.writeAll("            // .hash = \"...\",  // Add after first build\n");
        try writer.writeAll("        },\n");
    }

    try writer.writeAll("    },\n");

    // Paths - required by Zig 0.15+
    try writer.writeAll("    .paths = .{\n");
    try writer.writeAll("        \"build.zig\",\n");
    try writer.writeAll("        \"build.zig.zon\",\n");
    try writer.writeAll("        \"main.zig\",\n");
    try writer.writeAll("        \"project.labelle\",\n");
    try writer.writeAll("        \"scenes\",\n");
    try writer.writeAll("        \"prefabs\",\n");
    try writer.writeAll("        \"components\",\n");
    try writer.writeAll("        \"scripts\",\n");
    try writer.writeAll("        \"resources\",\n");
    try writer.writeAll("    },\n");

    try writer.writeAll("}\n");

    return buf.toOwnedSlice(allocator);
}

/// Generate build.zig content
pub fn generateBuildZig(allocator: std.mem.Allocator, config: ProjectConfig) ![]const u8 {
    var buf: std.ArrayListUnmanaged(u8) = .{};
    const writer = buf.writer(allocator);

    // Get the default backend from project config
    const default_backend = switch (config.backend) {
        .raylib => "raylib",
        .sokol => "sokol",
    };

    try writer.writeAll(
        \\const std = @import("std");
        \\
        \\/// Graphics backend selection (must match labelle-engine)
        \\pub const Backend = enum {
        \\    raylib,
        \\    sokol,
        \\};
        \\
        \\pub fn build(b: *std.Build) void {
        \\    const target = b.standardTargetOptions(.{});
        \\    const optimize = b.standardOptimizeOption(.{});
        \\
        \\    // Backend option - default comes from project.labelle, can be overridden via -Dbackend
        \\
    );

    try writer.print("    const backend = b.option(Backend, \"backend\", \"Graphics backend to use (default: {s})\") orelse .{s};\n", .{ default_backend, default_backend });

    try writer.writeAll(
        \\
        \\    const engine_dep = b.dependency("labelle-engine", .{
        \\        .target = target,
        \\        .optimize = optimize,
        \\        .backend = backend,
        \\    });
        \\    const engine_mod = engine_dep.module("labelle-engine");
        \\
        \\    const exe = b.addExecutable(.{
        \\
    );

    try writer.print("        .name = \"{s}\",\n", .{config.name});

    try writer.writeAll(
        \\        .root_module = b.createModule(.{
        \\            .root_source_file = b.path("main.zig"),
        \\            .target = target,
        \\            .optimize = optimize,
        \\            .imports = &.{
        \\                .{ .name = "labelle-engine", .module = engine_mod },
        \\            },
        \\        }),
        \\    });
        \\
        \\    b.installArtifact(exe);
        \\
        \\    const run_cmd = b.addRunArtifact(exe);
        \\    run_cmd.step.dependOn(b.getInstallStep());
        \\
        \\    const run_step = b.step("run", "Run the game");
        \\    run_step.dependOn(&run_cmd.step);
        \\}
        \\
    );

    return buf.toOwnedSlice(allocator);
}

/// Generate main.zig content based on folder contents
pub fn generateMainZig(
    allocator: std.mem.Allocator,
    config: ProjectConfig,
    prefabs: []const []const u8,
    components: []const []const u8,
    scripts: []const []const u8,
) ![]const u8 {
    var buf: std.ArrayListUnmanaged(u8) = .{};
    const writer = buf.writer(allocator);

    // Header
    try writer.print(
        \\// Generated by labelle-engine for project: {s}
        \\// Do not edit manually - regenerate with: zig build generate
        \\
        \\const std = @import("std");
        \\const engine = @import("labelle-engine");
        \\
        \\const Game = engine.Game;
        \\const ProjectConfig = engine.ProjectConfig;
        \\
        \\
    , .{config.name});

    // Prefab imports
    if (prefabs.len > 0) {
        try writer.writeAll("// Prefabs\n");
        for (prefabs) |name| {
            try writer.print("const {s}_prefab = @import(\"prefabs/{s}.zig\");\n", .{ name, name });
        }
        try writer.writeAll("\n");
    }

    // Component imports
    if (components.len > 0) {
        try writer.writeAll("// Components\n");
        for (components) |name| {
            try writer.print("const {s}_comp = @import(\"components/{s}.zig\");\n", .{ name, name });
        }
        try writer.writeAll("\n");

        try writer.writeAll("// Component type exports\n");
        for (components) |name| {
            // Capitalize first letter for type name
            var type_name: [64]u8 = undefined;
            @memcpy(type_name[0..name.len], name);
            if (type_name[0] >= 'a' and type_name[0] <= 'z') {
                type_name[0] -= 32;
            }
            try writer.print("pub const {s} = {s}_comp.{s};\n", .{ type_name[0..name.len], name, type_name[0..name.len] });
        }
        try writer.writeAll("\n");
    }

    // Script imports
    if (scripts.len > 0) {
        try writer.writeAll("// Scripts\n");
        for (scripts) |name| {
            try writer.print("const {s}_script = @import(\"scripts/{s}.zig\");\n", .{ name, name });
        }
        try writer.writeAll("\n");
    }

    // Registries
    try writer.writeAll("// Registries\n");

    // Prefab registry
    if (prefabs.len > 0) {
        try writer.writeAll("pub const Prefabs = engine.PrefabRegistry(.{\n");
        for (prefabs) |name| {
            try writer.print("    {s}_prefab,\n", .{name});
        }
        try writer.writeAll("});\n\n");
    } else {
        try writer.writeAll("pub const Prefabs = engine.PrefabRegistry(.{});\n\n");
    }

    // Component registry
    try writer.writeAll("const main_module = @This();\n\n");
    if (components.len > 0) {
        try writer.writeAll("pub const Components = engine.ComponentRegistry(struct {\n");
        for (components) |name| {
            var type_name: [64]u8 = undefined;
            @memcpy(type_name[0..name.len], name);
            if (type_name[0] >= 'a' and type_name[0] <= 'z') {
                type_name[0] -= 32;
            }
            try writer.print("    pub const {s} = main_module.{s};\n", .{ type_name[0..name.len], type_name[0..name.len] });
        }
        try writer.writeAll("});\n\n");
    } else {
        try writer.writeAll("pub const Components = engine.ComponentRegistry(struct {});\n\n");
    }

    // Script registry
    if (scripts.len > 0) {
        try writer.writeAll("pub const Scripts = engine.ScriptRegistry(struct {\n");
        for (scripts) |name| {
            try writer.print("    pub const {s} = {s}_script;\n", .{ name, name });
        }
        try writer.writeAll("});\n\n");
    } else {
        try writer.writeAll("pub const Scripts = engine.ScriptRegistry(struct {});\n\n");
    }

    // Scene loader and initial scene
    try writer.writeAll("pub const Loader = engine.SceneLoader(Prefabs, Components, Scripts);\n");
    try writer.print("pub const initial_scene = @import(\"scenes/{s}.zon\");\n\n", .{config.initial_scene});

    // Main function
    try writer.writeAll(
        \\pub fn main() !void {
        \\    const ci_test = std.posix.getenv("CI_TEST") != null;
        \\
        \\    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
        \\    defer _ = gpa.deinit();
        \\    const allocator = gpa.allocator();
        \\
        \\    const project = try ProjectConfig.load(allocator, "project.labelle");
        \\    defer project.deinit(allocator);
        \\
        \\    // Convert title to sentinel-terminated string for window creation
        \\    const title = try allocator.dupeZ(u8, project.window.title);
        \\    defer allocator.free(title);
        \\
        \\    var game = try Game.init(allocator, .{
        \\        .window = .{
        \\            .width = project.window.width,
        \\            .height = project.window.height,
        \\            .title = title,
        \\            .target_fps = project.window.target_fps,
        \\            .hidden = ci_test,
        \\        },
        \\        .clear_color = .{ .r = 30, .g = 35, .b = 45 },
        \\    });
        \\    game.fixPointers(); // Fix internal pointers after struct is in final location
        \\    defer game.deinit();
        \\
        \\    // Load atlases from project config
        \\    for (project.resources.atlases) |atlas| {
        \\        try game.loadAtlas(atlas.name, atlas.json, atlas.texture);
        \\    }
        \\
        \\    const ctx = engine.SceneContext.init(&game);
        \\    var scene = try Loader.load(initial_scene, ctx);
        \\    defer scene.deinit();
        \\
        \\    if (ci_test) return;
        \\
        \\    while (game.isRunning()) {
        \\        const dt = game.getDeltaTime();
        \\        scene.update(dt);
        \\        game.getPipeline().sync(game.getRegistry());
        \\
        \\        const re = game.getRetainedEngine();
        \\        re.beginFrame();
        \\        re.render();
        \\        re.endFrame();
        \\    }
        \\}
        \\
    );

    return buf.toOwnedSlice(allocator);
}

/// Scan a folder for .zig files and return their names (without extension)
pub fn scanFolder(allocator: std.mem.Allocator, path: []const u8) ![]const []const u8 {
    var names: std.ArrayListUnmanaged([]const u8) = .{};
    errdefer {
        for (names.items) |n| allocator.free(n);
        names.deinit(allocator);
    }

    var dir = std.fs.cwd().openDir(path, .{ .iterate = true }) catch |err| {
        if (err == error.FileNotFound) return names.toOwnedSlice(allocator);
        return err;
    };
    defer dir.close();

    var iter = dir.iterate();
    while (try iter.next()) |entry| {
        if (entry.kind == .file and std.mem.endsWith(u8, entry.name, ".zig")) {
            const name = try allocator.dupe(u8, entry.name[0 .. entry.name.len - 4]);
            try names.append(allocator, name);
        }
    }

    return names.toOwnedSlice(allocator);
}

/// Options for project generation
pub const GenerateOptions = struct {
    /// Path to labelle-engine (for local development). If null, uses URL.
    engine_path: ?[]const u8 = null,
};

/// Generate all project files (build.zig, build.zig.zon, main.zig)
pub fn generateProject(allocator: std.mem.Allocator, project_path: []const u8, options: GenerateOptions) !void {
    // Load project config
    const labelle_path = try std.fs.path.join(allocator, &.{ project_path, "project.labelle" });
    defer allocator.free(labelle_path);

    const config = try ProjectConfig.load(allocator, labelle_path);
    defer config.deinit(allocator);

    // Scan folders
    const prefabs_path = try std.fs.path.join(allocator, &.{ project_path, "prefabs" });
    defer allocator.free(prefabs_path);
    const prefabs = try scanFolder(allocator, prefabs_path);
    defer {
        for (prefabs) |p| allocator.free(p);
        allocator.free(prefabs);
    }

    const components_path = try std.fs.path.join(allocator, &.{ project_path, "components" });
    defer allocator.free(components_path);
    const components = try scanFolder(allocator, components_path);
    defer {
        for (components) |c| allocator.free(c);
        allocator.free(components);
    }

    const scripts_path = try std.fs.path.join(allocator, &.{ project_path, "scripts" });
    defer allocator.free(scripts_path);
    const scripts = try scanFolder(allocator, scripts_path);
    defer {
        for (scripts) |s| allocator.free(s);
        allocator.free(scripts);
    }

    // Generate files
    const build_zig_zon = try generateBuildZon(allocator, config, .{
        .engine_path = options.engine_path,
    });
    defer allocator.free(build_zig_zon);

    const build_zig = try generateBuildZig(allocator, config);
    defer allocator.free(build_zig);

    const main_zig = try generateMainZig(allocator, config, prefabs, components, scripts);
    defer allocator.free(main_zig);

    // Write files
    const build_zig_zon_path = try std.fs.path.join(allocator, &.{ project_path, "build.zig.zon" });
    defer allocator.free(build_zig_zon_path);
    const build_zig_path = try std.fs.path.join(allocator, &.{ project_path, "build.zig" });
    defer allocator.free(build_zig_path);
    const main_zig_path = try std.fs.path.join(allocator, &.{ project_path, "main.zig" });
    defer allocator.free(main_zig_path);

    const cwd = std.fs.cwd();
    try cwd.writeFile(.{ .sub_path = build_zig_zon_path, .data = build_zig_zon });
    try cwd.writeFile(.{ .sub_path = build_zig_path, .data = build_zig });
    try cwd.writeFile(.{ .sub_path = main_zig_path, .data = main_zig });
}

/// Generate only main.zig (for use during build when build.zig already exists)
pub fn generateMainOnly(allocator: std.mem.Allocator, project_path: []const u8) !void {
    // Load project config
    const labelle_path = try std.fs.path.join(allocator, &.{ project_path, "project.labelle" });
    defer allocator.free(labelle_path);

    const config = try ProjectConfig.load(allocator, labelle_path);
    defer config.deinit(allocator);

    // Scan folders
    const prefabs_path = try std.fs.path.join(allocator, &.{ project_path, "prefabs" });
    defer allocator.free(prefabs_path);
    const prefabs = try scanFolder(allocator, prefabs_path);
    defer {
        for (prefabs) |p| allocator.free(p);
        allocator.free(prefabs);
    }

    const components_path = try std.fs.path.join(allocator, &.{ project_path, "components" });
    defer allocator.free(components_path);
    const components = try scanFolder(allocator, components_path);
    defer {
        for (components) |c| allocator.free(c);
        allocator.free(components);
    }

    const scripts_path = try std.fs.path.join(allocator, &.{ project_path, "scripts" });
    defer allocator.free(scripts_path);
    const scripts = try scanFolder(allocator, scripts_path);
    defer {
        for (scripts) |s| allocator.free(s);
        allocator.free(scripts);
    }

    // Generate main.zig
    const main_zig = try generateMainZig(allocator, config, prefabs, components, scripts);
    defer allocator.free(main_zig);

    // Write main.zig
    const main_zig_path = try std.fs.path.join(allocator, &.{ project_path, "main.zig" });
    defer allocator.free(main_zig_path);

    const cwd = std.fs.cwd();
    try cwd.writeFile(.{ .sub_path = main_zig_path, .data = main_zig });
}
