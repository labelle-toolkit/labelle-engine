.header
// ============================================================================
// AUTO-GENERATED FILE - DO NOT EDIT
// ============================================================================
// This file is generated by labelle-engine from project.labelle
// Project: {s}
//
// Any manual changes will be overwritten on next generation.
//
// To regenerate: zig build generate
// To modify settings: edit project.labelle instead
//
// WASM BUILD - Uses sokol callbacks for browser compatibility.
// Config is embedded at compile time (no runtime file I/O).
// ============================================================================

const std = @import("std");
const engine = @import("labelle-engine");

// Sokol bindings for callback registration
const sokol = @import("sokol");
const sg = sokol.gfx;
const sgl = sokol.gl;
const sapp = sokol.app;

.plugin_import
const {s} = @import("{s}");
.enum_import
const {s}_enum = @import("enums/{s}.zig");
.enum_export
pub const {s} = {s}_enum.{s};
.game_id_export
pub const GameId = {s};
.plugin_bind
pub const {s}Bind{s} = {s}.{s}({s}, engine.EngineTypes);
.plugin_bind_struct_start
const {s}BindComponents = struct {{
.plugin_bind_struct_item
    pub const {s} = {s}Bind{s}.{s};
.plugin_bind_struct_end
}};
.prefab_import
const {s}_prefab = @import("prefabs/{s}.zon");
.component_import
const {s}_comp = @import("components/{s}.zig");
.component_export
pub const {s} = {s}_comp.{s};
.script_import
const {s}_script = @import("scripts/{s}.zig");
.hook_import
const {s}_hooks = @import("hooks/{s}.zig");
.main_module
const main_module = @This();
.prefab_registry_empty
pub const Prefabs = engine.PrefabRegistry(.{{}});
.prefab_registry_start
pub const Prefabs = engine.PrefabRegistry(.{{
.prefab_registry_item
    .{s} = {s}_prefab,
.prefab_registry_end
}});
.component_registry_empty
pub const Components = engine.ComponentRegistry(struct {{
    // Engine built-in components
    pub const Position = engine.Position;
    pub const Sprite = engine.Sprite;
    pub const Shape = engine.Shape;
    pub const Text = engine.Text;
.physics_components
    // Physics components (auto-included when physics is enabled)
    pub const RigidBody = engine.PhysicsComponents.RigidBody;
    pub const Collider = engine.PhysicsComponents.Collider;
    pub const Velocity = engine.PhysicsComponents.Velocity;
.component_registry_empty_end
}});
.component_registry_start
pub const Components = engine.ComponentRegistry(struct {{
    // Engine built-in components
    pub const Position = engine.Position;
    pub const Sprite = engine.Sprite;
    pub const Shape = engine.Shape;
    pub const Text = engine.Text;
    // Project components
.component_registry_item
    pub const {s} = main_module.{s};
.component_registry_bind_item
    pub const {s} = {s}Bind{s}.{s};
.component_registry_physics
    // Physics components (auto-included when physics is enabled)
    pub const RigidBody = engine.PhysicsComponents.RigidBody;
    pub const Collider = engine.PhysicsComponents.Collider;
    pub const Velocity = engine.PhysicsComponents.Velocity;
.component_registry_end
}});
.component_registry_multi_empty_start
pub const Components = engine.ComponentRegistryMulti(.{{
    struct {{
        // Engine built-in components
        pub const Position = engine.Position;
        pub const Sprite = engine.Sprite;
        pub const Shape = engine.Shape;
        pub const Text = engine.Text;
.component_registry_multi_physics
        // Physics components (auto-included when physics is enabled)
        pub const RigidBody = engine.PhysicsComponents.RigidBody;
        pub const Collider = engine.PhysicsComponents.Collider;
        pub const Velocity = engine.PhysicsComponents.Velocity;
.component_registry_multi_empty_base_end
    }},
.component_registry_multi_start
pub const Components = engine.ComponentRegistryMulti(.{{
    struct {{
        // Engine built-in components
        pub const Position = engine.Position;
        pub const Sprite = engine.Sprite;
        pub const Shape = engine.Shape;
        pub const Text = engine.Text;
        // Project components
.component_registry_multi_item
        pub const {s} = main_module.{s};
.bind_component_item
        pub const {s} = {s}Bind{s}.{s};
.component_registry_multi_physics_start
        // Physics components (auto-included when physics is enabled)
        pub const RigidBody = engine.PhysicsComponents.RigidBody;
        pub const Collider = engine.PhysicsComponents.Collider;
        pub const Velocity = engine.PhysicsComponents.Velocity;
.component_registry_multi_base_end
    }},
.component_registry_multi_plugin
    {s}.{s},
.component_registry_multi_bind
    {s}Bind{s},
.component_registry_multi_end
}});
.script_registry_empty
pub const Scripts = engine.ScriptRegistry(struct {{}});
.script_registry_start
pub const Scripts = engine.ScriptRegistry(struct {{
.script_registry_item
    pub const {s} = {s}_script;
.script_registry_end
}});
.plugin_engine_hooks
const {s}_engine_hooks = {s}.{s}(GameId, {s}, {s}_hooks.{s}, engine.EngineTypes);
pub const {s}Context = {s}_engine_hooks.Context;
.hooks_empty
const Game = engine.Game;
.hooks_start
const Hooks = engine.MergeEngineHooks(.{{
.hooks_item
    {s}_hooks,
.hooks_plugin_item
    {s}_engine_hooks,
.hooks_end
}});
const Game = engine.GameWith(Hooks);
.task_engine_empty

.task_engine_start
// Task engine with auto-wired hooks
const TaskHooks = {s}.hooks.MergeTasksHooks({s}, {s}, .{{
.task_engine_hook_item
    {s}_hooks,
.task_engine_end
}});
const TaskDispatcher = {s}.hooks.HookDispatcher({s}, {s}, TaskHooks);
pub const TaskEngine = {s}.EngineWithHooks({s}, {s}, TaskDispatcher);
.loader
pub const Loader = engine.SceneLoader(Prefabs, Components, Scripts);
pub const initial_scene = @import("scenes/{s}.zon");

.game_id
pub const GameId = u64;

.state
// Global state for sokol callback pattern
// Sokol uses callbacks, so we need global state accessible from init/frame/cleanup
const State = struct {{
    allocator: std.mem.Allocator = undefined,
    game: ?*Game = null,
    scene: ?*engine.Scene = null,
    initialized: bool = false,
    should_quit: bool = false,
    ci_test: bool = false,
    frame_count: u32 = 0,
}};

var state: State = .{{}};

// Allocated storage for game and scene (needed because sokol callbacks can't return errors)
var game_storage: Game = undefined;
var scene_storage: engine.Scene = undefined;

.plugin_context

.init_cb
export fn init() void {{
    // Initialize sokol_gfx with sokol_app's rendering context
    sg.setup(.{{
        .environment = sokol.glue.environment(),
        .logger = .{{ .func = sokol.log.func }},
    }});

    // Initialize sokol_gl for 2D drawing
    sgl.setup(.{{
        .logger = .{{ .func = sokol.log.func }},
    }});

    // Use c_allocator for WASM (page_allocator doesn't work in Emscripten)
    const allocator = std.heap.c_allocator;

    // Initialize game with compile-time embedded config
    game_storage = Game.init(allocator, .{{
        .window = .{{
            .width = {d},
            .height = {d},
            .title = "{s}",
            .target_fps = {d},
        }},
        .clear_color = .{{ .r = 30, .g = 35, .b = 45 }},
    }}) catch |err| {{
        std.log.err("Failed to initialize game: {{}}", .{{err}});
        sapp.quit();
        return;
    }};
    state.game = &game_storage;
    state.game.?.fixPointers();

.camera_config
    // Apply embedded camera configuration
    state.game.?.setCameraPosition({d:.1}, {d:.1});
    state.game.?.setCameraZoom({d:.2});
.camera_config_end

.init_cb_end
    const ctx = engine.SceneContext.init(state.game.?);

    // Emit scene_before_load hook
    state.game.?.hook_dispatcher.emit(.{{ .scene_before_load = .{{ .name = initial_scene.name, .allocator = allocator }} }});

    // Load initial scene (embedded at compile time)
    scene_storage = Loader.load(initial_scene, ctx) catch |err| {{
        std.log.err("Failed to load scene: {{}}", .{{err}});
        sapp.quit();
        return;
    }};
    state.scene = &scene_storage;

    // Emit scene_load hook
    state.game.?.hook_dispatcher.emit(.{{ .scene_load = .{{ .name = initial_scene.name }} }});

    state.initialized = true;
    std.log.info("WASM game initialized! Canvas: {{}}x{{}}", .{{ sapp.width(), sapp.height() }});
}}

.frame_cb
export fn frame() void {{
    if (!state.initialized or state.game == null or state.scene == null) return;

    state.frame_count += 1;

    // Check for canvas resize
    const current_width = sapp.width();
    const current_height = sapp.height();
    if (current_width != state.canvas_width or current_height != state.canvas_height) {{
        state.canvas_width = current_width;
        state.canvas_height = current_height;
        // Notify game of resize (if handler exists)
        std.log.info("Canvas resized to {{}}x{{}}", .{{ current_width, current_height }});
    }}

    // Get delta time from sokol
    const dt: f32 = @floatCast(sapp.frameDuration());

    // Update scene (runs scripts)
    state.scene.?.update(dt);

    // Sync ECS components to graphics
    state.game.?.getPipeline().sync(state.game.?.getRegistry());

    // Begin sokol render pass
    var pass_action: sg.PassAction = .{{}};
    pass_action.colors[0] = .{{
        .load_action = .CLEAR,
        .clear_value = .{{ .r = 0.118, .g = 0.137, .b = 0.176, .a = 1.0 }},
    }};
    sg.beginPass(.{{
        .action = pass_action,
        .swapchain = sokol.glue.swapchain(),
    }});

    // Render
    const re = state.game.?.getRetainedEngine();
    re.beginFrame();
    re.render();
    re.endFrame();

    // End render pass
    sg.endPass();
    sg.commit();
}}

.cleanup_cb
export fn cleanup() void {{
    if (state.initialized and state.game != null) {{
        state.game.?.hook_dispatcher.emit(.{{ .scene_unload = .{{ .name = initial_scene.name }} }});
    }}

    if (state.scene) |scene| {{
        scene.deinit();
        state.scene = null;
    }}

    if (state.game) |game| {{
        state.game.?.hook_dispatcher.emit(.{{ .game_deinit = .{{}} }});
        game.deinit();
        state.game = null;
    }}

    sgl.shutdown();
    sg.shutdown();
}}

.event_cb
export fn event(ev: [*c]const sapp.Event) void {{
    const e = ev orelse return;

    switch (e.type) {{
        // Mouse events (desktop browser)
        .MOUSE_DOWN, .MOUSE_UP, .MOUSE_MOVE, .MOUSE_SCROLL => {{
            // TODO: Forward to game input system
        }},
        // Touch events (mobile browser)
        .TOUCHES_BEGAN, .TOUCHES_MOVED, .TOUCHES_ENDED, .TOUCHES_CANCELLED => {{
            // TODO: Forward to game input system
        }},
        // Keyboard events
        .KEY_DOWN, .KEY_UP, .CHAR => {{
            // TODO: Forward to game input system
        }},
        // Browser visibility change (tab hidden/shown)
        .SUSPENDED => {{
            std.log.info("Tab hidden / page suspended", .{{}});
            // TODO: Emit app_suspended hook, pause audio
        }},
        .RESUMED => {{
            std.log.info("Tab visible / page resumed", .{{}});
            // TODO: Emit app_resumed hook, resume audio
        }},
        // Window/canvas focus
        .FOCUSED, .UNFOCUSED => {{
            // Canvas gained/lost focus
        }},
        else => {{}},
    }}
}}

.main_fn
pub fn main() void {{
    // For WASM, sokol_app is started via sapp.run() which sets up the event loop
    sapp.run(.{{
        .init_cb = init,
        .frame_cb = frame,
        .cleanup_cb = cleanup,
        .event_cb = event,
        .width = {d},
        .height = {d},
        .window_title = "{s}",
        .logger = .{{ .func = sokol.log.func }},
        .html5_canvas_selector = "#canvas",
        .html5_canvas_resize = true,
        .html5_preserve_drawing_buffer = false,
        .html5_premultiplied_alpha = true,
        .html5_ask_leave_site = false,
    }});
}}
