// ============================================================================
// EXAMPLE: Tasks Plugin with Auto-wired Hooks
// ============================================================================
// This example demonstrates how the generator creates a TaskEngine type
// when task hooks are detected in the hooks/ folder.
//
// When you have:
// 1. labelle-tasks plugin in project.labelle with id_type and item_type
// 2. Hook functions like pickup_started, process_started, etc. in hooks/
//
// The generator automatically:
// - Creates TaskHooks by merging all hook files with task hooks
// - Creates TaskDispatcher from HookDispatcher
// - Creates TaskEngine type ready for use
//
// In a real project, this file would be auto-generated. This example shows
// what the generated code looks like and how to use the TaskEngine.
// ============================================================================

const std = @import("std");
const engine = @import("labelle-engine");
const tasks = @import("labelle_tasks");

// Import components
const items_comp = @import("components/items.zig");
pub const ItemType = items_comp.ItemType;

// Import hooks
const task_hooks = @import("hooks/task_hooks.zig");

// ============================================================================
// Auto-generated by generator when task hooks are detected:
// ============================================================================

// Hook dispatcher for the task engine (uses task_hooks directly since we have one hook file)
const TaskDispatcher = tasks.hooks.HookDispatcher(u32, ItemType, task_hooks);

// The TaskEngine type with auto-wired hooks
pub const TaskEngine = tasks.EngineWithHooks(u32, ItemType, TaskDispatcher);

// ============================================================================
// End of auto-generated code
// ============================================================================

// Scene loader setup
pub const Prefabs = engine.PrefabRegistry(.{});
pub const Components = engine.ComponentRegistry(struct {
    pub const Position = engine.Position;
    pub const Sprite = engine.Sprite;
    pub const Shape = engine.Shape;
    pub const Text = engine.Text;
});
pub const Scripts = engine.ScriptRegistry(struct {});
pub const Loader = engine.SceneLoader(Prefabs, Components, Scripts);
pub const initial_scene = @import("scenes/main.zon");

const Game = engine.Game;

pub fn main() !void {
    const ci_test = std.posix.getenv("CI_TEST") != null;

    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var game = try Game.init(allocator, .{
        .window = .{
            .width = 800,
            .height = 600,
            .title = "Tasks Plugin Example",
            .target_fps = 60,
            .hidden = ci_test,
        },
        .clear_color = .{ .r = 30, .g = 35, .b = 45 },
    });
    game.fixPointers();
    defer game.deinit();

    const ctx = engine.SceneContext.init(&game);
    var scene = try Loader.load(initial_scene, ctx);
    defer scene.deinit();

    // ========================================================================
    // Example: Using the TaskEngine
    // ========================================================================

    // Create the task engine (uses auto-generated type with wired hooks)
    // task_hooks is a comptime struct type with static methods, so we instantiate it as {}
    var task_engine = TaskEngine.init(allocator, TaskDispatcher.init(task_hooks{}));
    defer task_engine.deinit();

    // Define storage entity IDs (in a real game these would be from the ECS)
    const PANTRY_ID: u32 = 100;
    const BAKERY_IIS_ID: u32 = 101;
    const BAKERY_IOS_ID: u32 = 102;
    const BREAD_SHELF_ID: u32 = 103;
    const BAKERY_ID: u32 = 200;
    const BAKER_ID: u32 = 300;

    // Create storages (new simplified API - each storage holds one item type)
    try task_engine.addStorage(PANTRY_ID, .Flour); // Pantry has flour
    try task_engine.addStorage(BAKERY_IIS_ID, null); // Empty internal input
    try task_engine.addStorage(BAKERY_IOS_ID, null); // Empty internal output
    try task_engine.addStorage(BREAD_SHELF_ID, null); // Empty bread shelf

    // Create workstation
    try task_engine.addWorkstation(BAKERY_ID, .{
        .eis = &.{PANTRY_ID},
        .iis = &.{BAKERY_IIS_ID},
        .ios = &.{BAKERY_IOS_ID},
        .eos = &.{BREAD_SHELF_ID},
    });

    // Add a worker
    try task_engine.addWorker(BAKER_ID);

    std.log.info("Task engine initialized with bakery workstation", .{});
    std.log.info("Hooks will fire as the worker processes tasks", .{});

    // Simulate: Worker becomes available (triggers pickup_started hook)
    _ = task_engine.workerAvailable(BAKER_ID);

    if (ci_test) return;

    // Game loop
    var frame: u32 = 0;
    while (game.isRunning()) {
        const dt = game.getDeltaTime();
        _ = dt;
        scene.update(0);

        // Simulate worker completing steps (in a real game this would be
        // triggered by the pathfinding/movement system)
        if (frame == 30) {
            // Worker arrived at EIS, pickup complete
            _ = task_engine.pickupCompleted(BAKER_ID);
        }
        if (frame == 60) {
            // Work/process complete
            _ = task_engine.workCompleted(BAKERY_ID);
        }
        if (frame == 90) {
            // Worker arrived at EOS, store complete
            _ = task_engine.storeCompleted(BAKER_ID);
        }

        game.getPipeline().sync(game.getRegistry());

        const re = game.getRetainedEngine();
        re.beginFrame();
        re.render();
        re.endFrame();

        frame += 1;
        if (frame > 120) break; // Exit after demo
    }

    std.log.info("Demo complete!", .{});
}
